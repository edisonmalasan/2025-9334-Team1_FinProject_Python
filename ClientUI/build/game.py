
# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer


from pathlib import Path

# from tkinter import *
# Explicit imports to satisfy Flake8
from tkinter import *
from utils.FontLoader import FontLoader
from utils import ListUtility
from utils import OrbConnector as oc
import sys
from IDL import WhatsTheWord
from IDL import WhatsTheWord__POA
import threading
import time

import omniORB

# create orb connection
con = oc.ORBConnector(sys.argv)

player = WhatsTheWord.referenceClasses.Player(0, "GUI_Player", "password", 0, 0, -1, False)

class ClientCallbackImpl(WhatsTheWord__POA.client.ClientCallback):
    def __init__(self, game_controller):
        self.game_controller = game_controller
        
    def notify(self, values_list: WhatsTheWord.referenceClasses.ValuesList):
        window.after(0, lambda: self.game_controller.update(values_list))

class GameContainer(Frame):
    def __init__(self, canvas: Canvas, assets):
        self.canvas = canvas
        self.elements = {}
        self.assets = image_assets
        
        #container dimensions (x1, y1, x2, y2)
        self.x1, self.y1 = 0, 0
        self.width, self.height = 721.77, 370.31

        self.word_length = 0 #store current word length
        self.guessed_letters = [] #store guessed letters and status
        self.current_display = [] #store elements for display
        self.entry_var = None  #store user input
        self.on_letter_guessed = None  #callback for when a letter is guessed
        
        self._create_container()
        self._add_elements()
    
    def _create_container(self):
        """Create the container background/border"""
        self.elements['bg'] = self.canvas.create_rectangle(
            self.x1, self.y1,
            self.x1 + self.width, self.y1 + self.height,
            fill="#232323",
            outline="#FFAB24",
            width=2
        )
    
    def _add_elements(self):
        cx = self.x1 + self.width / 2  # horizontal center of the container
        top = self.y1 + 20  # vertical padding from top of container

        #TIME LEFT label
        self.elements['time_label'] = self.canvas.create_text(
            cx,
            top,
            anchor="n",
            text="TIME LEFT",
            fill="#FFFFFF",
            font=("Silkscreen Regular", 36 * -1),
        )
        top += 40  # spacing below label

        #TIMER value
        self.elements['time_value'] = self.canvas.create_text(
            cx,
            top,
            anchor="n",
            text="00:00",
            fill="#FFFFFF",
            font=("Silkscreen Regular", 24 * -1),
        )
        top += 50  # spacing below entry

        #GUESSES LEFT text
        self.elements['guesses_left'] = self.canvas.create_text(
            cx,
            top,
            anchor="n",
            text="GUESSES LEFT: 5",
            fill="#FFFFFF",
            font=("Silkscreen Regular", 20 * -1),
        )
        top += 120

        #ENTER TEXT Label
        self.elements['enter_text'] = self.canvas.create_text(
            cx,
            top,
            anchor="n",
            text="ENTER A LETTER:",
            fill="#F8EFE0",
            font=("Silkscreen Regular", 14 * -1),
        )
        top += 40

        #Entry letter
        entry_width = 150
        self.entry_var = StringVar()
        entry = Entry(
            bd=0,
            bg="#FFFFFF",
            fg="#000716",
            justify="center",
            highlightthickness=0,
            textvariable=self.entry_var,
            font=("Silkscreen Regular", 16 * -1),
            validate="key",
            validatecommand=(window.register(self._validate_entry), '%P')
        )
        
        #bind to enter(newline) key for submitting guesses
        entry.bind('<Return>', self._submit_guess)
        
        self.elements['entry_window'] = self.canvas.create_window(
            cx,
            top,
            width=entry_width,
            height=39.0,
            window=entry,
        )
        top += 30

        #tag for grp operations
        for key, item in self.elements.items():
            if isinstance(item, int):
                self.canvas.itemconfig(item, tags=("game_container",))
            
    def move(self, dx: float, dy: float):
        """Move entire container by dx, dy pixels"""
        self.canvas.move("game_container", dx, dy)
        self.x1 += dx
        self.y1 += dy
    
    def update_username(self, new_name: str):
        """Update username text"""
        self.canvas.itemconfig(self.elements['username'], text=new_name)

    def update_timer(self, countdown: str):
        """Update timer text"""
        self.canvas.itemconfig(self.elements['time_value'], text=countdown)

    def update_points(self, points: int):
        """Update points display"""
        self.canvas.itemconfig(self.elements['points'], text=f"{points} points")

    def set_word_length(self, length: int):
        """Set the length of the word to be guessed"""
        self.word_length = length
        self.guessed_letters = []
        self.clear_display()
        self.create_initial_display()
    
    def clear_display(self):
        """Clear all letter display elements"""
        for item in self.current_display:
            self.canvas.delete(item)
        self.current_display = []

    def create_initial_display(self):
        """Create the initial display with empty lines"""
        cx = self.x1 + self.width / 2  # horizontal center
        start_x = cx - (self.word_length * 30) / 2  # center the letters
        
        for i in range(self.word_length):
            #creaate line for each letter
            line = self.canvas.create_rectangle(
                start_x + i * 30 + 10,  # x1
                self.y1 + 200,         # y1
                start_x + i * 30 + 30,  # x2 (20px wide)
                self.y1 + 203,          # y2 (3px tall)
                fill="#FFAB24",
                outline=""
            )
            self.current_display.append(line)

    def update_letters_guessed(self, letter: str, is_correct: bool, positions=None):
        if not self.word_length:
            return  #no word length set
            
        #track letters guessed (position and letter)
        self.guessed_letters.append((letter.upper(), is_correct, positions))
        
        self.clear_display()
        self.create_initial_display()
        
        cx = self.x1 + self.width / 2
        start_x = cx - (self.word_length * 30) / 2
        
        #display the correct guesses and their relativ positions
        for idx in range(self.word_length):
            #to check if any letter is in the correct position
            for l, correct, positions in self.guessed_letters:
                if correct and positions and idx in positions:
                    #show letter in its correct position
                    text = self.canvas.create_text(
                        start_x + idx * 30 + 20,
                        self.y1 + 180,
                        text=l,
                        fill="#FFAB24",  #yellow if correct
                        font=("Silkscreen Regular", 36 * -1),
                        anchor="s"
                    )
                    self.current_display.append(text)
        
        #container for incorrect guesses
        incorrect_letters = [l for l, correct, _ in self.guessed_letters if not correct]
        if incorrect_letters:
            #show incorrect guesses in an area
            text = self.canvas.create_text(
                cx,
                self.y1 + 210,
                text=f"Wrong: {', '.join(incorrect_letters)}",
                fill="#FF0000",  #red for wrong lmao
                font=("Silkscreen Regular", 16 * -1),
                anchor="n"
            )
            self.current_display.append(text)
    
    def _validate_entry(self, new_text):
        """Validation function for the Entry widget"""
        #allow empty string for backspace
        if not new_text:
            return True
        #allow only single alphabetic chars
        return len(new_text) == 1 and new_text.isalpha()
    
    def _submit_guess(self, event=None):
        """Handle submission of a letter guess"""
        if not self.entry_var:
            return
            
        letter = self.entry_var.get().upper()
        if not letter or len(letter) != 1:
            return
            
        #clear entry
        self.entry_var.set("")
        
        # If we have a callback, call it with the guessed letter
        if self.on_letter_guessed:
            #return if correct guess
            result = self.on_letter_guessed(letter)
            if result is not None:  #only update if leter was not already guessed
                is_correct, positions = result
                self.update_letters_guessed(letter, is_correct, positions)

    def set_on_letter_guessed(self, callback):
        """Set the callback for when a letter is guessed"""
        self.on_letter_guessed = callback        

    def hide(self):
        """Hide the entire container"""
        self.canvas.itemconfig("winner_container", state="hidden")
    
    def show(self):
        """Show the entire container"""
        self.canvas.itemconfig("winner_container", state="normal")
    
    def set_position(self, x: float, y: float):
        """Move container to absolute position"""
        dx = x - self.x1
        dy = y - self.y1
        self.move(dx, dy)
    
    def set_position_center(self, canvas_width:float, canvas_height:float):
        "Move container to center"
        dx = (canvas_width - self.width) / 2
        dy = (canvas_height - self.height) / 2
        self.set_position(dx,dy)

class GameController:
    def __init__(self, game_container):
        self.player = None
        self.game_container = game_container
        self.game_over = False
        self.point = 0
        self.timer_value = 0
        self.current_time = 0
        self.mystery_word = ""
        self.guessed_letters = set()
        self.lives = 5
        self.timer_thread = None
        self.stop_timer = False
        self.callback_impl = ClientCallbackImpl(self)
        self.callback_ref = None
        
        #callback for letter guesses
        self.game_container.set_on_letter_guessed(self.handle_letter_guess)

    def play_game(self, value_list):
        self.timer_value = get_int_from_list(value_list)
        self.mystery_word = get_string_from_list(value_list).upper()
        
        self.guessed_letters = set()
        self.lives = 5
        self.game_over = False
        self.stop_timer = False
        
        #update gui
        self.game_container.set_word_length(len(self.mystery_word))
        self.game_container.canvas.itemconfig(
            self.game_container.elements['guesses_left'],
            text=f"GUESSES LEFT: {self.lives}"
        )
        self.update_timer_display(self.timer_value)
        
        self.start_timer()

    def start_timer(self):
        if self.timer_thread and self.timer_thread.is_alive():
            self.stop_timer = True
            self.timer_thread.join()
            
        self.stop_timer = False
        self.timer_thread = threading.Thread(target=self.run_timer)
        self.timer_thread.start()

    def run_timer(self):
        current_time = self.timer_value
        while current_time >= 0 and not self.game_over and not self.stop_timer:
            self.current_time = current_time
            self.update_timer_display(current_time)
            time.sleep(1)
            current_time -= 1
            
        if not self.game_over and not self.stop_timer:
            self.game_over = True
            self.show_tooltip("Time's up!")
            

    def update_timer_display(self, seconds):
        mins, secs = divmod(seconds, 60)
        time_str = f"{mins:02d}:{secs:02d}"
        self.game_container.update_timer(time_str)

    def handle_letter_guess(self, letter):
        """Callback function for when a letter is guessed"""
        letter = letter.upper()
        
        if letter in self.guessed_letters:
            self.show_tooltip(f"'{letter}' was already guessed")
            return None  # No update needed
        
        self.guessed_letters.add(letter)
        
        # Check if letter is in word
        positions = [i for i, l in enumerate(self.mystery_word) if l == letter]
        is_correct = bool(positions)
        
        if not is_correct:
            self.lives -= 1
            self.game_container.canvas.itemconfig(
                self.game_container.elements['guesses_left'],
                text=f"GUESSES LEFT: {self.lives}"
            )
            self.show_tooltip(f"'{letter}' is not in the word")
            
            if self.lives <= 0:
                self.game_over = True
                self.show_tooltip("Game Over! No more guesses left.")
        
        if self._is_word_fully_guessed():
            self.point += 1
            game_container.update_points(self.point)
            self.show_tooltip(f"You won! The word was {self.mystery_word}")
            
        return is_correct, positions

    def _is_word_fully_guessed(self):
        """Check if all letters in the word have been guessed"""
        return all(letter in self.guessed_letters for letter in self.mystery_word)

    def show_tooltip(self, message):
        """Show a temporary message to the player"""
        cx = self.game_container.x1 + self.game_container.width / 2
        tooltip = self.game_container.canvas.create_text(
            cx,
            self.game_container.y1 + 300,
            text=message,
            fill="#FF0000",
            font=("Silkscreen Regular", 14 * -1),
            anchor="n"
        )
        self.game_container.canvas.after(2000, lambda: self.game_container.canvas.delete(tooltip))

    def update(self, value_list):
        winner = get_winner_from_list(value_list)

        if winner != "" or winner == "*NOT_ENOUGH_PLAYERS*":
            result_controller = ResultsController()
            result_controller.displayWinner(winner)
        else:
            self.play_game(value_list)

    def initialize_corba(self):
        self.callback_ref = self.callback_impl._this()
        con.getPlayerService().request(WhatsTheWord.client.player.START_GAME, player, self.callback_ref)
    
    def handle_forfeit(self, input: bool):
        self.game_over = input

#path declarations
OUTPUT_PATH = Path(__file__).parent
ASSETS_PATH = OUTPUT_PATH / Path(r"C:\Users\paulp\VSCODE_REPO\2025-9334-team1_finproject_python\ClientUI\build\assets\game")
font_loader = FontLoader(Path(r"C:\Users\paulp\VSCODE_REPO\2025-9334-team1_finproject_python\ClientUI\build\assets\fonts"))

def relative_to_assets(path: str) -> Path:
    return ASSETS_PATH / Path(path)

#window initialization
window = Tk()

window.geometry("985x589")
window.configure(bg = "#FFFFFF")

#font loaders
font_loader.load_tk_font("silkscreen", "Silkscreen", 24)
font_loader.load_tk_font("montserrat", "Montserrat", 18, weight="bold")

canvas = Canvas(
    window,
    bg = "#FFFFFF",
    height = 589,
    width = 985,
    bd = 0,
    highlightthickness = 0,
    relief = "ridge"
)

canvas.place(x = 0, y = 0)

#bg image
image_image_1 = PhotoImage(
    file=relative_to_assets("image_1.png"))
image_1 = canvas.create_image(
    500.0,
    300.0,
    image=image_image_1
)

#image assets
image_assets = {
    'image_2': PhotoImage(file=relative_to_assets("image_2.png")),
    'image_4': PhotoImage(file=relative_to_assets("image_4.png")),
    'button_1': PhotoImage(file=relative_to_assets("button_1.png"))
}

#forfeit button
button_image_1 = PhotoImage(
    file=relative_to_assets("button_1.png"))
button_1 = Button(
    image=button_image_1,
    borderwidth=0,
    highlightthickness=0,
    command=lambda: game_controller.handle_forfeit(False),
    relief="flat",
    bg="#232323"
)
button_1.place(
    x=457.0,
    y=537.0,
    width=112.2258071899414,
    height=31.435800552368164
)

#user profile img
image_image_2 = PhotoImage(
    file=relative_to_assets("image_2.png"))
image_2 = canvas.create_image(
    117.0,
    54.305419921875,
    image=image_image_2
)

#username placeholder
canvas.create_text(
    75.0,
    35.0,
    anchor="nw",
    text="user",
    fill="#FFFFFF",
    font=("Montserrat Bold", 16 * -1)
)

#round value placeholder
canvas.create_text(
    352.0,
    10.0,
    anchor="nw",
    text="ROUND 1",
    fill="#FFFFFF",
    font=("Silkscreen Regular", 64 * -1)
)


def get_string_from_list(values_list):
    extracted_value = omniORB.any.from_any(values_list.values[0])
    if isinstance(extracted_value, str):
        str_from_any = extracted_value
    return str_from_any

def get_int_from_list(values_list):
    extracted_value = omniORB.any.from_any(values_list.values[1])
    if isinstance(extracted_value, int):
        int_from_any = extracted_value
    return int_from_any

def get_winner_from_list(values_list):
    extracted_value = omniORB.any.from_any(values_list.values[2])
    if isinstance(extracted_value, str):
        winner = extracted_value
    return winner


game_container = GameContainer(canvas, image_assets)
game_container.set_position_center(985, 589)

game_controller = GameController(game_container)
game_controller.initialize_corba()

test_values = omniORB.Any([omniORB.Any("PYTHON"), omniORB.Any(60)])  # Word: PYTHON, 60 seconds
game_controller.play_game(test_values)

window.resizable(False, False)
window.mainloop()

#im going crazy